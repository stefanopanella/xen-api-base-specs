From 65299b78001caf1c0c22e05b827db4c6be1dc12e Mon Sep 17 00:00:00 2001
From: Christian Lindig <christian.lindig@citrix.com>
Date: Thu, 26 May 2016 14:16:42 +0100
Subject: [PATCH] CA-210015 retry if lseek(2) doesn't support SEEK_DATA,
 SEEK_HOLE

This improves a patch from upstream that implemented a retry when
lseek(2) using SEEK_DATA or SEEK-HOLE failed. Improvement are:

* We keep using #ifdef to make sure to only use SEEK_DATA, SEEK_HOLE
  when it is defined on a platform.

* We retry when lseek(2) fails only when it is because the file system
  doesn't support SEEK_DATA or SEEK_HOLE. The previous patch retried
  irrespective of the reason for failure.

Signed-off-by: Christian Lindig <christian.lindig@citrix.com>
---
 lib/lseek64_stubs.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/lib/lseek64_stubs.c b/lib/lseek64_stubs.c
index ab7e35b..7fd9db8 100644
--- a/lib/lseek64_stubs.c
+++ b/lib/lseek64_stubs.c
@@ -17,6 +17,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/ioctl.h>
+#include <errno.h>
 
 #include <fcntl.h>
 #include <string.h>
@@ -48,6 +49,9 @@ CAMLprim value stub_lseek64_data(value fd, value ofs) {
   caml_enter_blocking_section();
 #if defined(SEEK_DATA)
   c_ret = lseek(c_fd, c_ofs, SEEK_DATA);
+  /* retry, if SEEK_DATA not supported on this file system */
+  if (c_ret == -1 && errno == EINVAL)
+    c_ret = lseek(c_fd, c_ofs, SEEK_SET);
 #else
   /* Set the file pointer to ofs; pretend there is data */
   c_ret = lseek(c_fd, c_ofs, SEEK_SET);
@@ -69,6 +73,9 @@ CAMLprim value stub_lseek64_hole(value fd, value ofs) {
   caml_enter_blocking_section();
 #if defined(SEEK_HOLE)
   c_ret = lseek(c_fd, c_ofs, SEEK_HOLE);
+  /* retry, if SEEK_HOLE not supported on this file system */
+  if (c_ret == -1 && errno == EINVAL)
+    c_ret = lseek(c_fd, c_ofs, SEEK_END);
 #else
   /* Set the file pointer to the end of the file; pretend
      there is no hole */
-- 
2.8.1

